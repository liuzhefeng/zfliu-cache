

# 并发笔记

### 线程池

1.newCachedThreadPool

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。![CachedThreadPool ](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\CachedThreadPool .png)

2.newFixedThreadPool

创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

3.newScheduledThreadPool

创建一个定长线程池，支持定时及周期性任务执行。

4.newSingleThreadExecutor       

 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

### 线程池构造函数参数![线程池构造函数的参数 ](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\线程池构造函数的参数 .png)

### corePoolSize和maxPoolSize

![corePoolSize和maxPoolSize ](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\corePoolSize和maxPoolSize .png)

（1）corePoolSize：线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程

（2）maxPoolSize： 线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。

### SynchronousQueue

SynchronousQueue作为**阻塞队列**的时候，对于每一个take的线程会**阻塞直到有一个put的线程放入元素**为止，反之亦然。在SynchronousQueue**内部没有任何存放元素的能力**。所以类似peek操作或者迭代器操作也是无效的，元素只能通过put类操作或者take类操作才有效。通常队列的**第一个元素**是当前**第一个等待的线程**。如果没有线程阻塞在该队列则poll会返回null。从Collection的视角来看SynchronousQueue表现为一个**空的集合**。

![SynchronousQueue](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\SynchronousQueue.png)

### 线程池结构![线程池结构](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\线程池结构.png)

### 线程池拒绝任务

![线程池拒绝任务](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\线程池拒绝任务.png)

1、直接丢弃（DiscardPolicy）

2、丢弃队列中最老的任务(DiscardOldestPolicy)。

3、抛异常(AbortPolicy)

4、将任务分给调用线程来执行(CallerRunsPolicy)

  ```java
 pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy ());
  ```



### 线程池添加线程规则![线程池添加线程规则  ](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\线程池添加线程规则  .png)

### ThreadLocal原理图

![ThreadLocal原理图](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\ThreadLocal原理图.png)

ThreadLocal称为线程本地变量，其为变量在每个线程中都创建了一个副本，每个线程都访问和修改本线程中变量的副本。

set()和get()

```
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        map.set(this, value);//this是当前threadLocal
    } else {
        createMap(t, value);
    }
}
public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
 ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;//返回当前thread的ThreadLocalMap
    }
```

另一种初始化ThreadLacl方法：重写initialValue

```java
new ThreadLocal<T>() {
        @Override
        protected T initialValue() {
            return null;
        }
    };
```

### ReentrantLock使用案例 ：电影院购票![ReentrantReadWriteLock具体用法 1](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\ReentrantReadWriteLock具体用法 1.png)

### ReentrantReadWriteLock流程

![ReentrantReadWriteLock具体用法 1](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\ReentrantReadWriteLock具体用法 1.png)

![ReentrantReadWriteLock具体用法 2](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\ReentrantReadWriteLock具体用法 2.png)

![ReentrantReadWriteLock具体用法 3](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\ReentrantReadWriteLock具体用法 3.png)

### 读锁插队策略

解决线程饥饿。

![读锁插队策略 1](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\读锁插队策略 1.png)

![读锁插队策略 2](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\读锁插队策略 2.png)

### 公平锁和不公平锁

![对比公平锁和非公平锁源码](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\对比公平锁和非公平锁源码.png)

判断wait Queue 里面有没有等待线程

### 公平锁

![公平锁1](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\公平锁1.png)

![公平锁2](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\公平锁2.png)

```java
private static ReentrantLock lock = new ReentrantLock(true);

public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
```

非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。

### 非公平锁

![非公平锁](C:\usr\视频\玩转Java并发工具，精通JUC，成为并发多面手\concurrency_tools_practice\课程图片\非公平锁.png)

